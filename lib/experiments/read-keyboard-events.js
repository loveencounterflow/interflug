// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, CP, IFL, L, PATH, PD, XE, assign, badge, debug, echo, f, help, info, jr, rpr, select, urge, warn, whisper,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = '明快打字机/EXPERIMENTS/KB';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  PD = require('pipedreams');

  ({XE, $, $async, select} = PD);

  ({assign, jr} = CND);

  L = this;

  CP = require('child_process');

  IFL = require('../..');

  f = function() {
    var ifl;
    ifl = IFL.new();
    IFL.set_window_ids(ifl);
    // IFL.switch_to_own_window        ifl
    IFL.switch_to_target_window(ifl);
    // IFL.send_text_to_target_window  ifl, "demonstrating Unicode: äöü 书争事𫞖𫠠𫠣"
    // IFL.switch_to_own_window        ifl
    debug(ifl);
    return g();
  };

  //-----------------------------------------------------------------------------------------------------------
  this.read_xmodmap = function() {
    var $assemble, $read_entry;
    //.........................................................................................................
    $read_entry = () => {
      var pattern;
      pattern = /^keycode\s+(?<code>[0-9]+)\s+=\s+(?<names>.+?)\s*$/;
      return $((d, send) => {
        var code, i, idx, len, match, name, names;
        if ((match = d.match(pattern)) == null) {
          return;
        }
        code = parseInt(match.groups.code, 10);
        names = match.groups.names.split(/\s+/);
        for (idx = i = 0, len = names.length; i < len; idx = ++i) {
          name = names[idx];
          names[idx] = name.toLowerCase();
        }
        return send({code, names});
      });
    };
    //.........................................................................................................
    $assemble = () => {
      var R, last;
      R = {};
      last = Symbol('last');
      return $({last}, (d, send) => {
        var i, key, len, name, ref, results, value;
        if (d === last) {
          for (key in R) {
            value = R[key];
            R[key] = [...value];
          }
          delete R['nosymbol'];
          return send(R);
        }
        ref = d.names;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          name = ref[i];
          results.push((R[name] != null ? R[name] : R[name] = new Set()).add(d.code));
        }
        return results;
      });
    };
    //.........................................................................................................
    return new Promise(function(resolve) {
      var path, pipeline, source;
      path = PATH.resolve(PATH.join(__dirname, '../../src/experiments/xmodmap'));
      pipeline = [];
      source = PD.read_from_file(path);
      pipeline.push(source);
      pipeline.push(PD.$split());
      pipeline.push($read_entry());
      pipeline.push($assemble());
      pipeline.push($(function(d, send) {
        return resolve(d);
      }));
      pipeline.push(PD.$drain());
      PD.pull(...pipeline);
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.read_xevevents = function() {
    var $assemble, $declutter, $filter_keypress_events, $group_lines, $parse_event_text, is_blank_line;
    //.........................................................................................................
    is_blank_line = (line) => {
      return (line.match(/^\s*$/)) != null;
    };
    //.........................................................................................................
    $group_lines = () => {
      var block, last;
      last = Symbol('last');
      block = null;
      return $({last}, (d, send) => {
        if (d === last) {
          if (block != null) {
            send(block);
          }
        } else if (is_blank_line(d)) {
          if (block != null) {
            send(block);
          }
          block = [];
        } else {
          (block != null ? block : block = []).push(d.trim());
        }
        return null;
      });
    };
    //.........................................................................................................
    $filter_keypress_events = () => {
      return PD.$filter((d) => {
        return d[0].startsWith('KeyPress');
      });
    };
    $declutter = () => {
      return $((d, send) => {
        return send(d.slice(2, d.length - 1).join('\n'));
      });
    };
    //.........................................................................................................
    $parse_event_text = () => {
      /* Source looks like this:
      ```
      state 0x0, keycode 16 (keysym 0x37, 7), same_screen YES,
      XLookupString gives 1 bytes: (37) "7"
      XmbLookupString gives 1 bytes: (37) "7"
      ```
      */
      var keycode_pattern, modifier_bitpattterns, modifiers, state_pattern, x_pattern;
      keycode_pattern = /\s+keycode\s+(?<value>[0-9]+)/m;
      state_pattern = /^state\s+0x(?<value>[0-9a-f]+)/m;
      x_pattern = /^XLookupString\s+gives\s+.*"(?<value>.+?)"$/m;
      modifiers = [];
      modifier_bitpattterns = {
        alt: 0b00001000, // 0x08
        altgr: 0b10000000, // 0x80
        control: 0b00000100, // 0x04
        meta: 0b01000000, // 0x40
        shift: 0b00000001 // 0x01
      };
      return $((d0, send) => {
        var d, i, len, match, modifier_bits, name, ref, ref1;
        d = {
          key: '^xev'
        };
        //.....................................................................................................
        if ((match = d0.match(keycode_pattern)) != null) {
          /* higher level software uses system keycode + 8, for whatever reason */
          d.code = (parseInt(match.groups.value, 10)) - 8;
        }
        //.....................................................................................................
        if ((match = d0.match(state_pattern)) != null) {
          modifiers.length = 0;
          modifier_bits = parseInt(match.groups.value, 16);
          ref = ['alt', 'altgr', 'ctrl', 'meta', 'shift'];
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            if ((modifier_bitpattterns[name] & modifier_bits) === 0) {
              continue;
            }
            d[name] = true;
            modifiers.push(name);
          }
          if (modifiers.length > 0) {
            d.modifiers = modifiers.join('+');
          }
        }
        //.....................................................................................................
        if ((match = d0.match(x_pattern)) != null) {
          d.text = match.groups.value;
        }
        //.....................................................................................................
        if (d.code == null) {
          return;
        }
        if (d.text == null) {
          return;
        }
        d.id = `${(ref1 = d.modifiers) != null ? ref1 : 'null'}-${d.code}`;
        //.....................................................................................................
        return send(d);
      });
    };
    //.........................................................................................................
    $assemble = () => {
      var R, last;
      R = {};
      last = Symbol('last');
      return $({last}, (d, send) => {
        if (d === last) {
          return send(R);
        }
        R[d.id] = d;
        return null;
      });
    };
    //.........................................................................................................
    return new Promise(function(resolve) {
      var path, pipeline, source;
      path = PATH.resolve(PATH.join(__dirname, '../../src/experiments/xev-events'));
      pipeline = [];
      source = PD.read_from_file(path);
      pipeline.push(source);
      pipeline.push(PD.$split());
      pipeline.push($group_lines());
      pipeline.push($filter_keypress_events());
      pipeline.push($declutter());
      pipeline.push($parse_event_text());
      pipeline.push($assemble());
      // pipeline.push PD.$show title: '33873-1'
      pipeline.push($(function(d, send) {
        return resolve(d);
      }));
      pipeline.push(PD.$drain());
      PD.pull(...pipeline);
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$decode_keyboard_event_buffer = function() {
    var keycodes;
    keycodes = require('./_key-event-codes.data');
    return $(function(buffer, send) {
      var code, move, name, ref, type, value;
      if ((type = buffer.readUInt16LE(16)) !== 1) {
        return null;
      }
      code = buffer.readUInt16LE(18);
      value = buffer.readInt32LE(20);
      move = value === 1 ? 'down' : 'up';
      name = (ref = keycodes[code]) != null ? ref : null;
      send({
        key: '^key',
        name,
        code,
        move
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$capture_levels = function() {
    var nested_levels, prv_shift, state;
    nested_levels = false;
    prv_shift = null;
    state = {
      leftshift: false,
      rightshift: false,
      leftmeta: false,
      rightmeta: false,
      leftctrl: false,
      rightctrl: false,
      leftalt: false,
      rightalt: false,
      capslock: false,
      numlock: false,
      insert: false,
      compose: false
    };
    //.........................................................................................................
    return $(function(d, send) {
      var is_shift, is_within_level, key, name, toggle;
      // debug '26622', d, prv_shift
      is_within_level = state[d.name];
      is_shift = is_within_level != null;
      if (is_shift) {
        if (d.move === 'down') {
          prv_shift = d.name;
        } else if (d.name === prv_shift) {
          if (!nested_levels) {
            for (name in state) {
              toggle = state[name];
              if (name === d.name) {
                continue;
              }
              if (toggle) {
                state[name] = false;
                send({
                  key: '>level',
                  name
                });
              }
            }
          }
          key = is_within_level ? '>level' : '<level';
          state[d.name] = !state[d.name];
          send({
            key,
            name: d.name
          });
        }
      } else {
        prv_shift = null;
      }
      return send(d);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$capture_modifiers = function() {
    var modifiers, state;
    modifiers = [];
    state = {
      shift: false,
      control: false,
      meta: false,
      alt: false,
      altgr: false,
      capslock: false
    };
    //.........................................................................................................
    return $(function(d, send) {
      var i, len, name, ref, ref1;
      if (d.key !== '^key') {
        return send(d);
      }
      switch (d.name) {
        case 'leftshift':
        case 'rightshift':
          state.shift = d.move === 'down';
          break;
        case 'leftmeta':
        case 'rightmeta':
          state.meta = d.move === 'down';
          break;
        case 'leftctrl':
        case 'rightctrl':
          state.ctrl = d.move === 'down';
          break;
        case 'leftalt':
          state.alt = d.move === 'down';
          break;
        case 'rightalt':
          state.altgr = d.move === 'down';
          break;
        case 'capslock':
          state.capslock = d.move === 'down';
          break;
        default:
          modifiers.length = 0;
          ref = ['alt', 'altgr', 'ctrl', 'meta', 'shift', 'capslock'];
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            if (!state[name]) {
              continue;
            }
            d[name] = true;
            modifiers.push(name);
          }
          if (modifiers.length > 0) {
            d.modifiers = modifiers.join('+');
          }
          d.id = `${(ref1 = d.modifiers) != null ? ref1 : 'null'}-${d.code}`;
          send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$map_keyboard_events = function(keyboard_mapping) {
    return $(function(d, send) {
      var mapping;
      if ((mapping = keyboard_mapping[d.id]) != null) {
        d.text = mapping.text;
      }
      return send(d);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$rechunk_buffer = function(bytecount) {
    return $((d, send) => {
      var i, n, ref, start, stop, type;
      if ((type = CND.type_of(d)) !== 'buffer') {
        throw new Error(`expected a buffer, got a ${type}`);
      }
      if ((modulo(d.length, bytecount)) !== 0) {
        throw new Error(`not a multiple of ${bytecount}: ${d.length}`);
      }
      for (n = i = 0, ref = Math.floor(d.length / bytecount); (0 <= ref ? i < ref : i > ref); n = 0 <= ref ? ++i : --i) {
        start = n * bytecount;
        stop = start + bytecount;
        send(d.slice(start, stop));
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.read_from_keyboard = function(keyboard_mapping) {
    var pipeline, source;
    // path      = '/dev/input/by-path/platform-i8042-serio-0-event-kbd'
    // source    = PD.read_chunks_from_file path, 24
    source = this.new_keyboard_bytestream();
    pipeline = [];
    pipeline.push(source);
    pipeline.push(PD.$watch(function(x) {
      var ref;
      return debug('µ29982', CND.type_of(x), (ref = x != null ? x.length : void 0) != null ? ref : null);
    }));
    pipeline.push(this.$rechunk_buffer(24));
    pipeline.push(PD.$show());
    pipeline.push(this.$decode_keyboard_event_buffer());
    pipeline.push(this.$capture_levels());
    pipeline.push(this.$capture_modifiers());
    pipeline.push(this.$map_keyboard_events(keyboard_mapping));
    //.........................................................................................................
    return PD.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$compose_keys = function() {
    var collector, composing, start_compose_id, stop_compose_id;
    start_compose_id = 'null-13'; // tick ('´')
    stop_compose_id = 'null-57'; // space
    collector = [];
    composing = false;
    return $((d, send) => {
      var CLIPBOARD, _, composed_txt, i, len, ref, translations;
      if (!((select(d, '^key')) && (d.move === 'down'))) {
        return send(d);
      }
      switch (d.id) {
        case start_compose_id:
          /* flush collected characters so far */
          debug('39383', 'start_compose_id');
          composing = true;
          collector.length = 0;
          break;
        case stop_compose_id:
          composing = false;
          if (!(collector.length > 0)) {
            return send(d);
          }
          composed_txt = `${collector.join('')}`;
          translations = {
            omega: 'ω',
            Omega: 'Ω'
          };
          composed_txt = (ref = translations[composed_txt]) != null ? ref : composed_txt;
          debug('39383', 'stop_compose_id', rpr(composed_txt));
          CLIPBOARD = require('clipboardy');
          CLIPBOARD.writeSync(composed_txt);
          // IFL.copy null, collector.join ''
          this.send_backspace();
          for (i = 0, len = collector.length; i < len; i++) {
            _ = collector[i];
            this.send_backspace();
          }
          this.send_backspace();
          this.send_paste();
          collector.length = 0;
          break;
        default:
          if (composing) {
            debug('39383', 'composing');
            collector.push(d.text);
          } else {
            send(d);
          }
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.send_backspace = function() {
    // wmctrl -i -a #{S.windows.target} &&
    // xte 'usleep 250000' 'keydown Control_L' 'key v' 'keyup Control_L' &&
    // wmctrl -i -a #{S.windows.self}""".replace /\s+/gs, ' '
    // CP.execSync """xte 'keydown BackSpace' 'keyup BackSpace' 'usleep 250000'"""
    return CP.execSync("xte 'keydown BackSpace' 'keyup BackSpace'");
  };

  //-----------------------------------------------------------------------------------------------------------
  this.send_paste = function() {
    return CP.execSync("xte 'keydown Control_L' 'key v' 'keyup Control_L'");
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$emit = function() {
    return PD.$watch(function(d) {
      return XE.emit(d);
    });
  };

  XE.listen_to_all((key, d) => {
    return (d.key === '^key' ? whisper : urge)('µ52982', jr(d));
  });

  //-----------------------------------------------------------------------------------------------------------
  this.demo = function() {
    warn("in case an EACCES error is raised, remember to run the keylogger with `sudo`");
    return new Promise(async(resolve, reject) => {
      var keyboard_mapping, pipeline, source;
      keyboard_mapping = (await L.read_xevevents());
      source = this.read_from_keyboard(keyboard_mapping);
      pipeline = [];
      pipeline.push(source);
      pipeline.push(this.$compose_keys());
      pipeline.push(this.$emit());
      // pipeline.push PD.$show()
      pipeline.push(PD.$drain(function() {
        return resolve();
      }));
      PD.pull(...pipeline);
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._new_stderr_catcher = function(command, cp) {
    var lines, pipeline, source;
    source = PD.read_from_nodejs_stream(cp.stderr);
    lines = [];
    pipeline = [];
    //.........................................................................................................
    cp.on('exit', function(code) {
      var message;
      if (code !== 0) {
        lines = lines.join('\n');
        message = `${lines}\nchild process ${jr(command)} exited with code ${code}`;
        throw new Error(message);
      }
      return null;
    });
    //.........................................................................................................
    pipeline.push(source);
    pipeline.push(PD.$split());
    pipeline.push(PD.$watch(function(line) {
      return lines.push(line);
    }));
    pipeline.push(PD.$drain());
    PD.pull(...pipeline);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_keyboard_bytestream = function() {
    var command, cp, path;
    path = PATH.resolve(PATH.join(__dirname, 'pipe-keyboard-to-stdout.js'));
    command = ['sudo', 'node', path];
    cp = CP.spawn(command[0], command.slice(1), {
      shell: false,
      encoding: 'buffer'
    });
    // debug '26652', "secondary PID:", cp.pid
    // debug '26652', "primary   PID:", process.pid
    // debug '26652', "primary   UID:", process.getuid()
    this._new_stderr_catcher(command, cp);
    return PD.read_from_nodejs_stream(cp.stdout);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.demo_keyboard_bytestream = function() {
    var pipeline, source;
    source = L.new_keyboard_bytestream();
    pipeline = [];
    pipeline.push(source);
    pipeline.push(PD.$show());
    pipeline.push(PD.$drain());
    PD.pull(...pipeline);
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // f()
    L = this;
    (async function() {
      // info '23883', keyboard_mapping
      // await L.read_xmodmap()
      return (await L.demo());
    })();
  }

  /*

dumpkeys
loadkeys -C /dev/console -c
sudo loadkeys -C /dev/console -c
man loadkeys
loadkeys -c ./.XCompose
sudo dumpkeys
sudo evtest /dev/input/event3

 9976  ~/.local/bin/kbdgen
 9977  history | less -SR +G
 9978  xkbcomp -a

`pip3 install kbdgen` is a program to write xkb configurations; not yet
been able to use it successfully

`xev` shows same keycodes as used by xmodmap

110 without fn
112 with fn

~/.Xmodmap

*/

}).call(this);

//# sourceMappingURL=read-keyboard-events.js.map
