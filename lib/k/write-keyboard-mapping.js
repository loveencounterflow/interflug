// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, PATH, PD, XE, assign, badge, debug, echo, help, info, jr, rpr, select, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'INTERFLUG/K/read-keyboard-mapping';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  PD = require('pipedreams');

  ({XE, $, $async, select} = PD);

  ({assign, jr} = CND);

  /*

  dumpkeys
  loadkeys -C /dev/console -c
  sudo loadkeys -C /dev/console -c
  man loadkeys
  loadkeys -c ./.XCompose
  sudo dumpkeys
  sudo evtest /dev/input/event3

   9976  ~/.local/bin/kbdgen
   9977  history | less -SR +G
   9978  xkbcomp -a

  `pip3 install kbdgen` is a program to write xkb configurations; not yet
  been able to use it successfully

  `xev` shows same keycodes as used by xmodmap

  110 without fn
  112 with fn

  ~/.Xmodmap

  */
  //-----------------------------------------------------------------------------------------------------------
  this.read_xmodmap = function() {
    var $assemble, $read_entry;
    //.........................................................................................................
    $read_entry = () => {
      var pattern;
      pattern = /^keycode\s+(?<code>[0-9]+)\s+=\s+(?<names>.+?)\s*$/;
      return $((d, send) => {
        var code, i, idx, len, match, name, names;
        if ((match = d.match(pattern)) == null) {
          return;
        }
        code = parseInt(match.groups.code, 10);
        names = match.groups.names.split(/\s+/);
        for (idx = i = 0, len = names.length; i < len; idx = ++i) {
          name = names[idx];
          names[idx] = name.toLowerCase();
        }
        return send({code, names});
      });
    };
    //.........................................................................................................
    $assemble = () => {
      var R, last;
      R = {};
      last = Symbol('last');
      return $({last}, (d, send) => {
        var i, key, len, name, ref, results, value;
        if (d === last) {
          for (key in R) {
            value = R[key];
            R[key] = [...value];
          }
          delete R['nosymbol'];
          return send(R);
        }
        ref = d.names;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          name = ref[i];
          results.push((R[name] != null ? R[name] : R[name] = new Set()).add(d.code));
        }
        return results;
      });
    };
    //.........................................................................................................
    return new Promise(function(resolve) {
      var path, pipeline, source;
      path = PATH.resolve(__dirname, '../../src/k/xmodmap');
      pipeline = [];
      source = PD.read_from_file(path);
      pipeline.push(source);
      pipeline.push(PD.$split());
      pipeline.push($read_entry());
      pipeline.push($assemble());
      pipeline.push($(function(d, send) {
        return resolve(d);
      }));
      pipeline.push(PD.$drain());
      PD.pull(...pipeline);
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.write_keyboard_mapping = function() {
    var $assemble, $declutter, $filter_keypress_events, $group_lines, $parse_event_text, is_blank_line;
    //.........................................................................................................
    is_blank_line = (line) => {
      return (line.match(/^\s*$/)) != null;
    };
    //.........................................................................................................
    $group_lines = () => {
      var block, last;
      last = Symbol('last');
      block = null;
      return $({last}, (d, send) => {
        if (d === last) {
          if (block != null) {
            send(block);
          }
        } else if (is_blank_line(d)) {
          if (block != null) {
            send(block);
          }
          block = [];
        } else {
          (block != null ? block : block = []).push(d.trim());
        }
        return null;
      });
    };
    //.........................................................................................................
    $filter_keypress_events = () => {
      return PD.$filter((d) => {
        return d[0].startsWith('KeyPress');
      });
    };
    $declutter = () => {
      return $((d, send) => {
        return send(d.slice(2, d.length - 1).join('\n'));
      });
    };
    //.........................................................................................................
    $parse_event_text = () => {
      /* Source looks like this:
      ```
      state 0x0, keycode 16 (keysym 0x37, 7), same_screen YES,
      XLookupString gives 1 bytes: (37) "7"
      XmbLookupString gives 1 bytes: (37) "7"
      ```
      */
      var keycode_pattern, modifier_bitpattterns, modifiers, state_pattern, x_pattern;
      keycode_pattern = /\s+keycode\s+(?<value>[0-9]+)/m;
      state_pattern = /^state\s+0x(?<value>[0-9a-f]+)/m;
      x_pattern = /^XLookupString\s+gives\s+.*"(?<value>.+?)"$/m;
      modifiers = [];
      modifier_bitpattterns = {
        alt: 0b00001000, // 0x08
        altgr: 0b10000000, // 0x80
        control: 0b00000100, // 0x04
        meta: 0b01000000, // 0x40
        shift: 0b00000001 // 0x01
      };
      return $((d0, send) => {
        var d, i, len, match, modifier_bits, name, ref, ref1;
        d = {
          key: '^xev'
        };
        //.....................................................................................................
        if ((match = d0.match(keycode_pattern)) != null) {
          /* higher level software uses system keycode + 8, for whatever reason */
          d.code = (parseInt(match.groups.value, 10)) - 8;
        }
        //.....................................................................................................
        if ((match = d0.match(state_pattern)) != null) {
          modifiers.length = 0;
          modifier_bits = parseInt(match.groups.value, 16);
          ref = ['alt', 'altgr', 'ctrl', 'meta', 'shift'];
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            if ((modifier_bitpattterns[name] & modifier_bits) === 0) {
              continue;
            }
            d[name] = true;
            modifiers.push(name);
          }
          if (modifiers.length > 0) {
            d.modifiers = modifiers.join('+');
          }
        }
        //.....................................................................................................
        if ((match = d0.match(x_pattern)) != null) {
          d.text = match.groups.value;
        }
        //.....................................................................................................
        if (d.code == null) {
          return;
        }
        if (d.text == null) {
          return;
        }
        d.id = `${(ref1 = d.modifiers) != null ? ref1 : 'null'}-${d.code}`;
        //.....................................................................................................
        return send(d);
      });
    };
    //.........................................................................................................
    $assemble = () => {
      var R, last;
      R = {};
      last = Symbol('last');
      return $({last}, (d, send) => {
        if (d === last) {
          return send(R);
        }
        R[d.id] = d;
        return null;
      });
    };
    //.........................................................................................................
    return new Promise((resolve, reject) => {
      var input_path, output_path, pipeline;
      input_path = PATH.resolve(__dirname, '../../src/k/xev-events');
      output_path = require(PATH.resolve(__dirname, '../../src/k/keyboard-map.json'));
      pipeline = [];
      pipeline.push(PD.read_from_file(input_path));
      pipeline.push(PD.$split());
      pipeline.push($group_lines());
      pipeline.push($filter_keypress_events());
      pipeline.push($declutter());
      pipeline.push($parse_event_text());
      pipeline.push($assemble());
      // pipeline.push PD.$show title: '33873-1'
      // pipeline.push $ ( d, send ) -> echo d
      pipeline.push(PD.write_to_file(output_path));
      PD.pull(...pipeline);
      return null;
    });
  };

  //###########################################################################################################
  if (module.parent == null) {
    this.write_keyboard_mapping();
  }

}).call(this);

//# sourceMappingURL=write-keyboard-mapping.js.map
