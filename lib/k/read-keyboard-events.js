// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, CP, IFL, L, PATH, PD, XE, assign, badge, debug, echo, help, info, jr, rpr, select, urge, warn, whisper,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'INTERFLUG/K';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  PD = require('pipedreams');

  ({XE, $, $async, select} = PD);

  ({assign, jr} = CND);

  L = this;

  CP = require('child_process');

  IFL = require('../..');

  //===========================================================================================================
  // READ KEYBOARD
  //-----------------------------------------------------------------------------------------------------------
  this.read_from_keyboard = function(keyboard_map = null) {
    var pipeline, source;
    // path      = '/dev/input/by-path/platform-i8042-serio-0-event-kbd'
    // source    = PD.read_chunks_from_file path, 24
    if (keyboard_map == null) {
      keyboard_map = require(PATH.resolve(__dirname, '../../src/k/keyboard-map.json'));
    }
    source = this._new_keyboard_bytestream();
    pipeline = [];
    pipeline.push(source);
    // pipeline.push PD.$watch ( x ) -> debug 'Âµ29982', ( CND.type_of x ), x?.length ? null
    pipeline.push(this._$rechunk_buffer(24));
    pipeline.push(this._$decode_keyboard_event_buffer());
    pipeline.push(this._$capture_levels());
    pipeline.push(this._$capture_modifiers());
    pipeline.push(this._$map_keyboard_events(keyboard_map));
    //.........................................................................................................
    return PD.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$rechunk_buffer = function(bytecount) {
    return $((d, send) => {
      var i, n, ref, start, stop, type;
      if ((type = CND.type_of(d)) !== 'buffer') {
        throw new Error(`expected a buffer, got a ${type}`);
      }
      if ((modulo(d.length, bytecount)) !== 0) {
        throw new Error(`not a multiple of ${bytecount}: ${d.length}`);
      }
//.......................................................................................................
      for (n = i = 0, ref = Math.floor(d.length / bytecount); (0 <= ref ? i < ref : i > ref); n = 0 <= ref ? ++i : --i) {
        start = n * bytecount;
        stop = start + bytecount;
        send(d.slice(start, stop));
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$decode_keyboard_event_buffer = function() {
    var keycodes;
    keycodes = require('./_key-event-codes.data');
    return $(function(buffer, send) {
      var code, move, name, ref, type, value;
      if ((type = buffer.readUInt16LE(16)) !== 1) {
        return null;
      }
      code = buffer.readUInt16LE(18);
      value = buffer.readInt32LE(20);
      move = value === 1 ? 'down' : 'up';
      name = (ref = keycodes[code]) != null ? ref : null;
      send({
        key: '^key',
        name,
        code,
        move
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$capture_levels = function() {
    var nested_levels, prv_shift, state;
    nested_levels = false;
    prv_shift = null;
    state = {
      leftshift: false,
      rightshift: false,
      leftmeta: false,
      rightmeta: false,
      leftctrl: false,
      rightctrl: false,
      leftalt: false,
      rightalt: false,
      capslock: false,
      numlock: false,
      insert: false,
      compose: false
    };
    //.........................................................................................................
    return $(function(d, send) {
      var is_shift, is_within_level, key, name, toggle;
      // debug '26622', d, prv_shift
      is_within_level = state[d.name];
      is_shift = is_within_level != null;
      if (is_shift) {
        if (d.move === 'down') {
          prv_shift = d.name;
        } else if (d.name === prv_shift) {
          if (!nested_levels) {
            for (name in state) {
              toggle = state[name];
              if (name === d.name) {
                continue;
              }
              if (toggle) {
                state[name] = false;
                send({
                  key: '>level',
                  name
                });
              }
            }
          }
          key = is_within_level ? '>level' : '<level';
          state[d.name] = !state[d.name];
          send({
            key,
            name: d.name
          });
        }
      } else {
        prv_shift = null;
      }
      return send(d);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$capture_modifiers = function() {
    var modifiers, state;
    modifiers = [];
    state = {
      shift: false,
      control: false,
      meta: false,
      alt: false,
      altgr: false,
      capslock: false
    };
    //.........................................................................................................
    return $(function(d, send) {
      var i, len, name, ref, ref1;
      if (d.key !== '^key') {
        return send(d);
      }
      switch (d.name) {
        case 'leftshift':
        case 'rightshift':
          state.shift = d.move === 'down';
          break;
        case 'leftmeta':
        case 'rightmeta':
          state.meta = d.move === 'down';
          break;
        case 'leftctrl':
        case 'rightctrl':
          state.ctrl = d.move === 'down';
          break;
        case 'leftalt':
          state.alt = d.move === 'down';
          break;
        case 'rightalt':
          state.altgr = d.move === 'down';
          break;
        case 'capslock':
          state.capslock = d.move === 'down';
          break;
        default:
          modifiers.length = 0;
          ref = ['alt', 'altgr', 'ctrl', 'meta', 'shift', 'capslock'];
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            if (!state[name]) {
              continue;
            }
            d[name] = true;
            modifiers.push(name);
          }
          if (modifiers.length > 0) {
            d.modifiers = modifiers.join('+');
          }
          d.id = `${(ref1 = d.modifiers) != null ? ref1 : 'null'}-${d.code}`;
          send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$map_keyboard_events = function(keyboard_map) {
    return $(function(d, send) {
      var mapping;
      if ((mapping = keyboard_map[d.id]) != null) {
        d.text = mapping.text;
      }
      return send(d);
    });
  };

  //===========================================================================================================
  this._new_keyboard_bytestream = function() {
    var command, cp, path;
    path = PATH.resolve(__dirname, 'pipe-keyboard-to-stdout.js');
    command = ['sudo', 'node', path];
    cp = CP.spawn(command[0], command.slice(1), {
      shell: false,
      encoding: 'buffer'
    });
    this._new_stderr_catcher(command, cp);
    return PD.read_from_nodejs_stream(cp.stdout);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._new_stderr_catcher = function(command, cp) {
    var lines, pipeline, source;
    source = PD.read_from_nodejs_stream(cp.stderr);
    lines = [];
    pipeline = [];
    //.........................................................................................................
    cp.on('exit', function(code) {
      var message;
      if (code !== 0) {
        lines = lines.join('\n');
        message = `${lines}\nchild process ${jr(command)} exited with code ${code}`;
        throw new Error(message);
      }
      return null;
    });
    //.........................................................................................................
    pipeline.push(source);
    pipeline.push(PD.$split());
    pipeline.push(PD.$watch(function(line) {
      return lines.push(line);
    }));
    pipeline.push(PD.$drain());
    PD.pull(...pipeline);
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // f()
    L = this;
    (async function() {
      // info '23883', keyboard_map
      // await L.read_xmodmap()
      return (await L.demo());
    })();
  }

}).call(this);

//# sourceMappingURL=read-keyboard-events.js.map
